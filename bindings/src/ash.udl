// ASH Core FFI Interface Definition
// This file defines the public API exposed to Swift
//
// Fountain code based QR transfer for reliable ceremony.

namespace ash {
    // === Pad Size Operations ===

    /// Get pad size in bytes for a given PadSize
    u64 get_pad_size_bytes(PadSize size);

    // === Fountain Ceremony Operations ===

    /// Create a fountain frame generator for ceremony QR display.
    ///
    /// This is the main entry point for initiators. The generator produces
    /// unlimited encoded blocks that can be displayed as QR codes.
    /// Passphrase is required for encrypting the QR frames.
    /// Method selects the transfer strategy (Raptor recommended).
    [Throws=AshError]
    FountainFrameGenerator create_fountain_generator(
        CeremonyMetadata metadata,
        sequence<u8> pad_bytes,
        u32 block_size,
        string passphrase,
        TransferMethod method
    );

    // === Authenticated Message Operations ===

    /// Authentication overhead per message (64 bytes for Wegman-Carter MAC)
    u32 get_auth_overhead();

    /// Calculate total pad consumption for a message
    /// Returns: auth_overhead (64) + plaintext_length
    u32 calculate_pad_consumption(u32 plaintext_length);

    /// Encrypt plaintext with Wegman-Carter authentication.
    ///
    /// This is the recommended encryption function. It provides:
    /// - OTP encryption (information-theoretic confidentiality)
    /// - Wegman-Carter MAC (information-theoretic authenticity)
    /// - Anti-malleability (any bit flip is detected)
    ///
    /// # Arguments
    /// - `auth_key`: 64 bytes from pad for authentication
    /// - `encryption_key`: N bytes from pad for encryption (same length as plaintext)
    /// - `plaintext`: Data to encrypt
    /// - `msg_type`: Message type (0x01 = text, 0x02 = location)
    ///
    /// # Returns
    /// Encoded message frame: [version][type][length][ciphertext][32-byte tag]
    [Throws=AshError]
    sequence<u8> encrypt_authenticated(
        sequence<u8> auth_key,
        sequence<u8> encryption_key,
        sequence<u8> plaintext,
        u8 msg_type
    );

    /// Decrypt and verify an authenticated message.
    ///
    /// Verifies the authentication tag BEFORE decryption.
    /// If verification fails, returns AuthenticationFailed error.
    ///
    /// # Arguments
    /// - `auth_key`: 64 bytes from pad for authentication
    /// - `encryption_key`: N bytes from pad for decryption (same length as ciphertext)
    /// - `encoded_frame`: Full message frame from encrypt_authenticated
    ///
    /// # Returns
    /// Tuple of (plaintext, message_type)
    [Throws=AshError]
    DecryptedMessage decrypt_authenticated(
        sequence<u8> auth_key,
        sequence<u8> encryption_key,
        sequence<u8> encoded_frame
    );

    // === Legacy OTP Operations (no authentication) ===

    /// Encrypt plaintext using OTP (XOR with key)
    /// WARNING: No authentication - use encrypt_authenticated for new code
    [Throws=AshError]
    sequence<u8> encrypt(sequence<u8> key, sequence<u8> plaintext);

    /// Decrypt ciphertext using OTP (XOR with key)
    /// WARNING: No authentication - use decrypt_authenticated for new code
    [Throws=AshError]
    sequence<u8> decrypt(sequence<u8> key, sequence<u8> ciphertext);

    // === Mnemonic Operations ===

    /// Generate 6-word mnemonic checksum from pad bytes
    sequence<string> generate_mnemonic(sequence<u8> pad_bytes);

    /// Generate mnemonic with custom word count
    sequence<string> generate_mnemonic_with_count(sequence<u8> pad_bytes, u32 word_count);

    // === Passphrase Validation ===

    /// Validate passphrase meets requirements (4-64 printable ASCII chars)
    boolean validate_passphrase(string passphrase);

    /// Get minimum passphrase length
    u32 get_min_passphrase_length();

    /// Get maximum passphrase length
    u32 get_max_passphrase_length();

    // === Authorization Token Operations ===

    /// Derive conversation ID from pad bytes (hex-encoded, 64 chars)
    [Throws=AshError]
    string derive_conversation_id(sequence<u8> pad_bytes);

    /// Derive auth token from pad bytes (hex-encoded, 64 chars)
    /// Used for API authentication (messages, polling, registration)
    [Throws=AshError]
    string derive_auth_token(sequence<u8> pad_bytes);

    /// Derive burn token from pad bytes (hex-encoded, 64 chars)
    /// Used specifically for burn operations (defense in depth)
    [Throws=AshError]
    string derive_burn_token(sequence<u8> pad_bytes);

    /// Derive all tokens at once (conversation_id, auth_token, burn_token)
    [Throws=AshError]
    AuthTokens derive_all_tokens(sequence<u8> pad_bytes);

    // === Secure Memory Operations ===

    /// Securely zero a byte array using volatile writes.
    /// This prevents the compiler from optimizing away the zeroing.
    /// Use this for wiping sensitive data from memory.
    void secure_zero_bytes(sequence<u8> data);

    // === Pad Calculator Operations ===

    /// Calculate source blocks (K) for given pad size and block size.
    /// Includes metadata overhead in calculation.
    u32 calculate_source_blocks(u64 pad_bytes, u32 block_size);

    /// Calculate expected frames needed for successful transfer.
    /// This is the number displayed in UI as "~X QR frames".
    u32 calculate_expected_frames(u64 pad_bytes, u32 block_size, TransferMethod method);

    /// Calculate redundancy blocks to pre-generate beyond source count.
    /// This is used for QR pre-generation to ensure enough frames are ready.
    u32 calculate_redundancy_blocks(u32 source_blocks, TransferMethod method);

    /// Calculate total frames to pre-generate (source + redundancy).
    u32 calculate_frames_to_generate(u64 pad_bytes, u32 block_size, TransferMethod method);

    /// Get metadata overhead constant (bytes added to pad for ceremony encoding).
    u32 get_metadata_overhead();

    /// Get default QR block size.
    u32 get_default_block_size();
};

/// Available pad sizes
enum PadSize {
    /// 32 KB - approximately 25 short messages
    "Tiny",
    /// 64 KB - approximately 50 short messages
    "Small",
    /// 256 KB - approximately 200 short messages
    "Medium",
    /// 512 KB - approximately 400 short messages
    "Large",
    /// 1 MB - approximately 800 short messages
    "Huge",
};

/// Role in the conversation, determining pad consumption direction.
///
/// The role is established during the ceremony:
/// - Initiator: The person who creates the ceremony (displays QR codes)
/// - Responder: The person who scans the ceremony QR codes
enum Role {
    /// Initiator consumes from the start of the pad
    "Initiator",
    /// Responder consumes from the end of the pad
    "Responder",
};

/// Transfer method for QR ceremony.
///
/// Determines which erasure coding strategy is used for pad transfer.
/// All methods use the same wire format, so receivers auto-adapt.
enum TransferMethod {
    /// Raptor codes - near-optimal, K + 2-5 blocks overhead (recommended)
    "Raptor",
    /// LT codes - legacy fountain codes, K + O(sqrt(K)) blocks overhead
    "LT",
    /// Sequential - plain numbered frames, no erasure coding
    "Sequential",
};

/// Error types for ASH operations
[Error]
enum AshError {
    /// Not enough bytes remaining in pad
    "InsufficientPadBytes",
    /// Entropy size doesn't match expected pad size
    "InvalidEntropySize",
    /// Key and data lengths don't match
    "LengthMismatch",
    /// CRC checksum failed
    "CrcMismatch",
    /// Payload cannot be empty
    "EmptyPayload",
    /// Fountain block is too short
    "FountainBlockTooShort",
    /// Metadata frame is too short
    "MetadataTooShort",
    /// Unsupported metadata version
    "UnsupportedMetadataVersion",
    /// Metadata URL is too long
    "MetadataUrlTooLong",
    /// Invalid UTF-8 in metadata URL
    "InvalidMetadataUrl",
    /// Pad is too small to derive authorization tokens
    "PadTooSmallForTokens",
    /// Message authentication failed
    "AuthenticationFailed",
    /// Invalid message padding
    "InvalidPadding",
};

/// Ceremony metadata transferred via QR frame 0
/// Contains settings agreed upon during ceremony
dictionary CeremonyMetadata {
    /// Protocol version (always 1)
    u8 version;
    /// Message TTL in seconds (default 300 = 5 minutes)
    u64 ttl_seconds;
    /// Disappearing messages timeout in seconds (0 = off)
    u32 disappearing_messages_seconds;
    /// Notification flags (16-bit bitfield) encoding various settings:
    ///
    /// Notification flags (bits 0-7):
    /// - Bit 0: NOTIFY_NEW_MESSAGE (0x0001) - notify on new message
    /// - Bit 1: NOTIFY_MESSAGE_EXPIRING (0x0002) - notify before message expires
    /// - Bit 2: NOTIFY_MESSAGE_EXPIRED (0x0004) - notify when message expires
    /// - Bit 3: NOTIFY_DELIVERY_FAILED (0x0008) - notify sender if TTL expires unread
    /// - Bit 4: NOTIFY_MESSAGE_READ (0x0010) - reserved for read receipts
    /// - Bits 5-7: Reserved for future notification types
    ///
    /// Security flags (bits 8-11):
    /// - Bit 8: Persistence consent (local message storage)
    /// - Bits 9-11: Message padding settings (enabled + size)
    ///
    /// UI flags (bits 12-15):
    /// - Bits 12-15: Conversation accent color (16 colors)
    ///
    /// Default: 0x000B (new message + expiring + delivery failed)
    u16 notification_flags;
    /// Transfer method used for QR ceremony (Raptor, LT, or Sequential)
    TransferMethod transfer_method;
    /// Relay server URL
    string relay_url;
};

/// Authorization tokens derived from pad during ceremony
dictionary AuthTokens {
    /// Conversation ID (hex-encoded, 64 chars)
    string conversation_id;
    /// Auth token for API operations (hex-encoded, 64 chars)
    string auth_token;
    /// Burn token for burn operations (hex-encoded, 64 chars)
    string burn_token;
};

/// Result of authenticated decryption
dictionary DecryptedMessage {
    /// Decrypted plaintext
    sequence<u8> plaintext;
    /// Message type (0x01 = text, 0x02 = location)
    u8 msg_type;
    /// Authentication tag (32 bytes) - can be shown in UI
    sequence<u8> tag;
};

/// Result of fountain ceremony decoding
dictionary FountainCeremonyResult {
    /// Ceremony metadata (settings)
    CeremonyMetadata metadata;
    /// Reconstructed pad bytes
    sequence<u8> pad;
    /// Number of blocks used for decoding
    u32 blocks_used;
};

/// One-Time Pad with bidirectional consumption semantics
///
/// The pad uses bidirectional consumption:
/// - Initiator consumes from the start of the pad
/// - Responder consumes from the end of the pad
///
/// This allows both parties to send messages without coordination.
interface Pad {
    /// Create pad from entropy bytes with a specific size.
    /// The entropy length must match the specified pad size.
    [Throws=AshError, Name=from_entropy]
    constructor(sequence<u8> entropy, PadSize size);

    /// Create pad from raw bytes (for reconstruction)
    [Name=from_bytes]
    constructor(sequence<u8> bytes);

    /// Create pad from raw bytes with pre-existing consumption state
    /// Used when restoring a pad from persistent storage.
    [Name=from_bytes_with_state]
    constructor(sequence<u8> bytes, u64 consumed_front, u64 consumed_back);

    /// Consume next n bytes from pad based on role
    /// - Initiator consumes from the start (moving forward)
    /// - Responder consumes from the end (moving backward)
    [Throws=AshError]
    sequence<u8> consume(u32 n, Role role);

    /// Get remaining bytes count (available for either role)
    u64 remaining();

    /// Get total pad size
    u64 total_size();

    /// Get total consumed bytes count (both directions)
    u64 consumed();

    /// Get bytes consumed from start (by Initiator)
    u64 consumed_front();

    /// Get bytes consumed from end (by Responder)
    u64 consumed_back();

    /// Check if pad is exhausted
    boolean is_exhausted();

    /// Get raw bytes for ceremony transfer
    sequence<u8> as_bytes();

    /// Check if we can send a message of the given length (dynamic allocation)
    boolean can_send(u32 length, Role role);

    /// Get the number of bytes available for sending (dynamic allocation)
    u64 available_for_sending(Role role);

    /// Update peer's consumption based on a received message
    void update_peer_consumption(Role peer_role, u64 new_consumed);

    /// Get the offset for the next message we send
    u64 next_send_offset(Role role);

    /// Securely zero bytes at a specific offset (for forward secrecy).
    ///
    /// When a message expires, this zeros the key material used to encrypt it,
    /// preventing future decryption even if the pad is compromised.
    ///
    /// Returns true if bytes were zeroed, false if offset/length is out of bounds.
    boolean zero_bytes_at(u64 offset, u64 length);
};

/// Fountain frame generator for QR display.
///
/// Generates unlimited encoded blocks from ceremony data. The display
/// cycles through blocks until the receiver signals completion.
///
/// # Block Types
///
/// - Blocks 0..K: Source blocks (direct data, no encoding overhead)
/// - Blocks K+: XOR blocks (combinations of two source blocks)
interface FountainFrameGenerator {
    /// Generate the next QR frame bytes.
    ///
    /// Can be called infinitely - generates new blocks each time.
    /// Blocks cycle through source blocks first, then XOR blocks.
    sequence<u8> next_frame();

    /// Generate a specific block by index.
    ///
    /// Useful for regenerating specific blocks or random access.
    /// Same index always produces same block (deterministic).
    sequence<u8> generate_frame(u32 index);

    /// Number of source blocks (minimum needed for decoding).
    u32 source_count();

    /// Block size in bytes.
    u32 block_size();

    /// Total data size being transferred (metadata + pad).
    u32 total_size();
};

/// Fountain frame receiver for QR scanning.
///
/// Collects scanned blocks and tracks decoding progress.
/// Automatically detects transfer method from first received block
/// and uses the appropriate decoder (Raptor, LT, or Sequential).
interface FountainFrameReceiver {
    /// Create a new receiver.
    /// Passphrase is required and must match the sender's passphrase.
    constructor(string passphrase);

    /// Add a scanned QR frame.
    ///
    /// Returns true if decoding is now complete, false if more blocks needed.
    /// Duplicate blocks are safely ignored.
    /// Transfer method is auto-detected from block 0.
    [Throws=AshError]
    boolean add_frame(sequence<u8> frame_bytes);

    /// Check if decoding is complete.
    boolean is_complete();

    /// Get decoding progress (0.0 to 1.0).
    f64 progress();

    /// Number of blocks received (including duplicates).
    u32 blocks_received();

    /// Number of unique blocks received (excluding duplicates).
    /// This is more useful for progress tracking.
    u32 unique_blocks_received();

    /// Number of source blocks needed for complete decoding.
    /// Returns 0 before the first block is received.
    u32 source_count();

    /// Get the detected transfer method.
    /// Returns null if block 0 hasn't been received yet.
    TransferMethod? detected_method();

    /// Get the decoded ceremony result.
    /// Returns null if decoding is not complete.
    FountainCeremonyResult? get_result();
};
