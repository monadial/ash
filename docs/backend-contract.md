# ASH — Backend Contract (v1)

This document defines the **backend contract** for ASH version 1.

It is not a full API reference.  
It is a set of **invariants, responsibilities, and behavioral guarantees** that every backend implementation must follow.

This document must be consistent with:
- `scope.md`
- `threat-model.md`
- `architecture.md`

---

## Purpose

The ASH backend is a **dumb relay with a clock**.

It exists only to:
- relay encrypted message blobs between devices
- relay burn signals
- notify devices via silent push notifications (APNS)

The backend is assumed **untrusted**.

---

## Core invariants (non-negotiable)

1. **No plaintext**
   - The backend must never receive, store, or emit plaintext message content.

2. **No interpretation**
   - The backend must not parse message payloads beyond basic framing for routing and limits.

3. **No identity**
   - The backend must not maintain user accounts, usernames, phone numbers, emails, contacts, or profiles.

4. **No long-term storage**
   - All stored data is ephemeral and must be TTL-expired.

5. **No analytics/tracking**
   - No behavioral analytics, tracking IDs, fingerprinting, or user profiling.

6. **Best-effort delivery**
   - Delivery is not guaranteed.
   - Loss, delay, and duplication are acceptable within defined limits.

7. **HTTPS only**
   - All endpoints require TLS.
   - No plaintext HTTP.

8. **Minimal logging**
   - Logs must not contain ciphertext or conversation identifiers in a way that enables correlation.
   - Prefer aggregate operational logs over per-request traces.

---

## Concepts

### Conversation ID
A conversation is addressed by a **Conversation ID**, generated by the clients during the ceremony.

- The backend treats it as an **opaque identifier**.
- It is not tied to a user identity.

### Encrypted Blob
An encrypted blob is an opaque payload produced by OTP encryption on the client.

The backend must treat it as:
- untrusted input
- opaque bytes
- non-inspectable

### Burn
A burn is a signal meaning:
- “Forget this conversation state as soon as you see this.”

Burn is **best-effort**.  
If a device is offline, it receives burn when it next connects.

---

## Data handling

### What the backend may store (ephemeral)
- `conversation_id -> encrypted blobs`
- `conversation_id -> burn flag (timestamp)`
- `conversation_id -> registered device tokens (APNS)`
- operational counters (aggregate)

### TTL policy (v1)

| Data type | Default | Range | Notes |
|-----------|---------|-------|-------|
| Encrypted blobs | 5 min | 5 min – 7 days | Configured at ceremony, deleted on ACK or expiry |
| Auth token hashes | ∞ | N/A | Lost on server restart (RAM only) |
| Burn flag | 5 min | Fixed | Allows late-arriving clients to learn of burn |
| Device tokens | 24 hours | Fixed | Must re-register periodically |

The backend must delete expired data automatically via background cleanup task (runs every 10 seconds).

**Message TTL:**
- Configured during ceremony (stored in ceremony metadata)
- Default: 5 minutes (maximum ephemerality)
- Maximum: 7 days (604,800 seconds)
- Messages deleted on ACK or TTL expiry, whichever comes first

**Server restart:**
- All RAM data lost (messages, auth tokens, device tokens)
- Clients must re-register conversation after restart
- Server returns 404 "conversation not found" for unknown conversations

### Persistence

**Default (v1):** In-memory storage
- Simple implementation
- Data lost on restart
- Suitable for active conversations

**Optional:** Lightweight persistence (e.g., SQLite)
- Required for extended TTL (delayed message reading)
- Must enforce TTL cleanup
- No backups or replication
- Data encrypted at rest

**Disallowed:**
- Long-term archives
- Backups without TTL
- Analytics stores
- Replication to other systems

---

## Transport model

### SSE + Polling (v1)

v1 uses **Server-Sent Events (SSE)** for real-time delivery with polling as fallback.

**Primary: SSE (Server-Sent Events)**
- Long-lived HTTP connection for real-time message delivery
- Endpoint: `GET /v1/messages/stream?conversation_id=...`
- Keep-alive ping every 15 seconds
- Automatically broadcasts new messages and burn events
- Requires auth token in `Authorization` header

**Fallback: HTTP Polling**
- Used when SSE connection unavailable
- When a conversation screen is open: poll every **1–2 seconds**
- When app is backgrounded: no polling

**Wake-up: Push Notifications (APNS)**
- Silent push notifications wake the app when backgrounded
- App then connects via SSE or polls for messages
- Best-effort delivery (not guaranteed)

---

## Authentication / authorization model

v1 uses **no accounts** but requires **token-based authorization**.

### Token-based authorization

Both ceremony participants derive tokens from the shared pad:
- **Conversation ID** - Identifies the conversation (derived from pad bytes 0-31)
- **Auth Token** - Authenticates API requests (derived from pad bytes 32-95)
- **Burn Token** - Required for burn operations only (derived from pad bytes 96-159)

### Registration flow

After ceremony, both parties register with the backend:

```
POST /v1/conversations
{
  "conversation_id": "...",
  "auth_token_hash": "sha256(...)",  // 64 hex chars
  "burn_token_hash": "sha256(...)"   // 64 hex chars
}
```

The backend stores only **hashes** of tokens. It can verify but not forge tokens.

### Authorization headers

All protected endpoints require:
```
Authorization: Bearer <auth_token>
```

For burn operations, use `burn_token` instead of `auth_token` (defense in depth).

### Token properties

- Tokens do not encode user identity
- Tokens do not include PII
- Tokens are deterministically derived from pad
- Both parties derive identical tokens from shared pad

---

## API surface (contract-level)

This section describes required behaviors.  
Exact paths and schemas may vary, but semantics must match.

### 0) Register conversation

**Goal:** Register a conversation's authorization tokens with the server.

- Endpoint: `POST /v1/conversations`
- Input:
  ```json
  {
    "conversation_id": "hex string (64 chars)",
    "auth_token_hash": "sha256 hash (64 hex chars)",
    "burn_token_hash": "sha256 hash (64 hex chars)"
  }
  ```
- Success: `200 OK` with `{"success": true}`
- Errors:
  - `400 INVALID_INPUT` - malformed request

**Invariants:**
- Must store only hashes (cannot reverse to get tokens)
- Idempotent (both parties call after ceremony)
- Must be called again after server restart
- No authorization header required (uses conversation_id as identifier)

---

### 1) Register device for push notifications

**Goal:** Associate a device token with a conversation (ephemerally).

- Endpoint: `POST /v1/register`
- Headers: `Authorization: Bearer <auth_token>`
- Input:
  ```json
  {
    "conversation_id": "...",
    "device_token": "apns device token",
    "platform": "ios" | "macos"
  }
  ```
- Success: `200 OK` with `{"success": true}`
- Errors:
  - `400 INVALID_INPUT` - invalid device token
  - `401 MISSING_AUTH` - no Authorization header
  - `401 UNAUTHORIZED` - invalid token
  - `404 CONVERSATION_NOT_FOUND` - must register conversation first
  - `410 CONVERSATION_BURNED` - conversation was burned

**Invariants:**
- Requires valid auth token
- Must not store device token longer than TTL policy (24 hours)
- Must not associate token with identity
- Must be called again after server restart

---

### 2) Submit encrypted message blob

**Goal:** Accept opaque ciphertext for a conversation.

- Endpoint: `POST /v1/messages`
- Headers: `Authorization: Bearer <auth_token>`
- Input:
  ```json
  {
    "conversation_id": "...",
    "ciphertext": "base64 encoded",
    "sequence": 123  // optional
  }
  ```
- Success: `200 OK` with `{"accepted": true, "blob_id": "uuid"}`
- Errors:
  - `400 INVALID_INPUT` - invalid base64 or missing fields
  - `401 MISSING_AUTH` / `401 UNAUTHORIZED` - auth errors
  - `404 CONVERSATION_NOT_FOUND` - re-register required
  - `410 CONVERSATION_BURNED` - conversation was burned
  - `413 PAYLOAD_TOO_LARGE` - ciphertext > 8KB
  - `429 QUEUE_FULL` - too many pending messages (50 max)

**Invariants:**
- Store ciphertext only ephemerally
- Must enforce size limits
- Must not log ciphertext
- Should trigger silent push (APNS) to registered devices (best-effort)
- Should broadcast via SSE to connected clients

---

### 3) Poll for messages

**Goal:** Return new ciphertext blobs for a conversation.

- Endpoint: `GET /v1/messages?conversation_id=...&cursor=...`
- Headers: `Authorization: Bearer <auth_token>`
- Success: `200 OK` with:
  ```json
  {
    "messages": [
      {"id": "uuid", "sequence": 123, "ciphertext": "base64", "received_at": "..."}
    ],
    "next_cursor": "base64 encoded cursor",
    "burned": false
  }
  ```
- Errors:
  - `401 MISSING_AUTH` / `401 UNAUTHORIZED` - auth errors
  - `404 CONVERSATION_NOT_FOUND` - re-register required

**Invariants:**
- Must not reorder blobs unnecessarily
- Must allow duplicates (client must tolerate)
- Must allow empty responses
- Must not block indefinitely (short timeouts)
- Returns `burned: true` if conversation was burned

---

### 4) Acknowledge message (ACK)

**Goal:** Confirm message was displayed and trigger deletion.

- Endpoint: `POST /v1/ack`
- Headers: `Authorization: Bearer <auth_token>`
- Input:
  ```json
  {
    "conversation_id": "...",
    "blob_id": "uuid"
  }
  ```
- Success: `200 OK` with `{"accepted": true}`
- Errors:
  - `401 MISSING_AUTH` / `401 UNAUTHORIZED` - auth errors
  - `404 CONVERSATION_NOT_FOUND` - re-register required

**Invariants:**
- Must delete the blob from RAM immediately
- Must broadcast `delivered` event via SSE to conversation participants
- ACK is idempotent (ACKing already-deleted blob returns success)
- Must not log blob contents

**SSE delivery event:**
```json
{"type": "delivered", "blob_id": "uuid", "delivered_at": "..."}
```

---

### 5) Burn conversation

**Goal:** Signal all participants to wipe state.

- Endpoint: `POST /v1/burn`
- Headers: `Authorization: Bearer <burn_token>` (**burn token, not auth token**)
- Input:
  ```json
  {
    "conversation_id": "..."
  }
  ```
- Success: `200 OK` with `{"accepted": true}`
- Errors:
  - `401 MISSING_AUTH` / `401 UNAUTHORIZED` - invalid burn token
  - `404 CONVERSATION_NOT_FOUND` - re-register required

**Invariants:**
- Requires **burn token** (not auth token) for defense in depth
- Must set burn flag with TTL
- Must delete queued blobs immediately for that conversation
- Must remove auth token hashes
- Should trigger silent push (APNS) to registered devices (best-effort)
- Must broadcast `burned` event via SSE

---

### 6) Poll burn status (optional)

**Goal:** Check if conversation has been burned.

- Endpoint: `GET /v1/burn?conversation_id=...`
- Headers: `Authorization: Bearer <auth_token>`
- Success: `200 OK` with:
  ```json
  {
    "burned": true,
    "burned_at": "2025-01-04T12:00:00Z"
  }
  ```
- Errors:
  - `401 MISSING_AUTH` / `401 UNAUTHORIZED` - auth errors
  - `404 CONVERSATION_NOT_FOUND` - re-register required

**Note:** Burn status is also returned in poll response (`burned` field).

---

### 7) SSE message stream

**Goal:** Provide real-time message delivery via Server-Sent Events.

- Endpoint: `GET /v1/messages/stream?conversation_id=...`
- Headers: `Authorization: Bearer <auth_token>`
- Success: `200 OK` with SSE stream (Content-Type: text/event-stream)
- Errors:
  - `401 MISSING_AUTH` / `401 UNAUTHORIZED` - auth errors
  - `404 CONVERSATION_NOT_FOUND` - re-register required

**Event types:**
```json
{"type": "message", "id": "uuid", "sequence": 123, "ciphertext": "base64...", "received_at": "..."}
{"type": "delivered", "blob_id": "uuid", "delivered_at": "..."}
{"type": "burned", "burned_at": "2025-01-04T12:00:00Z"}
{"type": "ping"}
```

**Invariants:**
- Connection requires valid auth token
- Keep-alive ping every 15 seconds
- Messages broadcast to all connected clients for conversation
- Burns broadcast immediately to all connected clients
- Must handle reconnection gracefully
- Client should reconnect on connection loss

---

## HTTP Status Codes

All error responses follow a consistent format:

```json
{
  "error": "Human-readable error message",
  "code": "MACHINE_READABLE_CODE"
}
```

### Success codes

| Code | Meaning |
|------|---------|
| `200 OK` | Request successful |

### Client error codes

| Code | Error Code | Meaning | Client Action |
|------|------------|---------|---------------|
| `400 BAD_REQUEST` | `INVALID_INPUT` | Malformed request | Fix request format |
| `400 BAD_REQUEST` | `INVALID_AUTH` | Invalid Authorization header format | Use `Bearer <token>` |
| `401 UNAUTHORIZED` | `MISSING_AUTH` | Missing Authorization header | Add auth header |
| `401 UNAUTHORIZED` | `UNAUTHORIZED` | Invalid or expired token | Check token, re-register |
| `404 NOT_FOUND` | `CONVERSATION_NOT_FOUND` | Conversation not registered | Re-register conversation |
| `410 GONE` | `CONVERSATION_BURNED` | Conversation has been burned | Remove local state |
| `413 PAYLOAD_TOO_LARGE` | `PAYLOAD_TOO_LARGE` | Ciphertext exceeds 8KB limit | Reduce message size |
| `429 TOO_MANY_REQUESTS` | `QUEUE_FULL` | Message queue full (50 max) | Retry later |

### Server error codes

| Code | Error Code | Meaning |
|------|------------|---------|
| `500 INTERNAL_SERVER_ERROR` | `INTERNAL_ERROR` | Server error | Retry later |

### Re-registration trigger

When receiving `404 CONVERSATION_NOT_FOUND`, clients must:
1. Call `POST /v1/conversations` with token hashes
2. Call `POST /v1/register` with device token
3. Retry the failed request

---

## Limits (must exist)

The backend must enforce defensive limits to reduce abuse and resource exhaustion.

Recommended v1 limits:
- Max ciphertext size per message: **<= 8 KB** (tunable)
- Max queued blobs per conversation: **<= 50**
- Max active conversations per IP per minute: rate limit
- Max register calls per conversation per TTL: rate limit

The backend must respond with clear errors on limit violations.

---

## Failure modes (must be acceptable)

Clients must assume the backend may:
- drop messages
- delay messages
- duplicate messages
- return out-of-date burn info briefly
- temporarily reject requests

The backend must:
- fail fast
- avoid hanging requests
- prefer correctness and simplicity over throughput

---

## Observability (privacy-preserving)

Allowed metrics (aggregate only):
- request counts per endpoint
- response status counts
- latency histograms
- queue lengths (aggregate)
- TTL cleanup counts

Disallowed:
- per-conversation analytics
- per-device analytics
- payload logging
- “user journey” tracking

---

## Security requirements

### TLS
- HTTPS only
- Modern TLS configuration
- HSTS enabled

### Input validation
- Validate sizes and formats
- Treat all input as untrusted
- Reject malformed payloads early

### Logging
- No ciphertext logging
- No device token logging
- Avoid logging conversation IDs
- Use short request IDs for correlation if needed

---

## Compatibility and versioning

The backend must support API versioning (e.g., `/v1/...`).

Breaking changes require:
- new version endpoints
- backwards-compatible rollout strategy

---

## Contract tests (recommended)

Backend implementations should include contract-level tests verifying:
- TTL deletion
- burn deletes queued blobs
- polling returns expected cursors
- size limits enforced
- no payloads written to logs in tests

---

## Final note

The backend is deliberately minimal.

If a new backend feature:
- adds identity
- adds persistent state
- interprets payloads
- or increases trust in infrastructure

it violates ASH’s architecture and must not be implemented in v1.