# ASH — Backend Contract (v1)

This document defines the **backend contract** for ASH version 1.

It is not a full API reference.  
It is a set of **invariants, responsibilities, and behavioral guarantees** that every backend implementation must follow.

This document must be consistent with:
- `scope.md`
- `threat-model.md`
- `architecture.md`

---

## Purpose

The ASH backend is a **dumb relay with a clock**.

It exists only to:
- relay encrypted message blobs between devices
- relay burn signals
- notify devices via silent push notifications (APNS)

The backend is assumed **untrusted**.

---

## Core invariants (non-negotiable)

1. **No plaintext**
   - The backend must never receive, store, or emit plaintext message content.

2. **No interpretation**
   - The backend must not parse message payloads beyond basic framing for routing and limits.

3. **No identity**
   - The backend must not maintain user accounts, usernames, phone numbers, emails, contacts, or profiles.

4. **No long-term storage**
   - All stored data is ephemeral and must be TTL-expired.

5. **No analytics/tracking**
   - No behavioral analytics, tracking IDs, fingerprinting, or user profiling.

6. **Best-effort delivery**
   - Delivery is not guaranteed.
   - Loss, delay, and duplication are acceptable within defined limits.

7. **HTTPS only**
   - All endpoints require TLS.
   - No plaintext HTTP.

8. **Minimal logging**
   - Logs must not contain ciphertext or conversation identifiers in a way that enables correlation.
   - Prefer aggregate operational logs over per-request traces.

---

## Concepts

### Conversation ID
A conversation is addressed by a **Conversation ID**, generated by the clients during the ceremony.

- The backend treats it as an **opaque identifier**.
- It is not tied to a user identity.

### Encrypted Blob
An encrypted blob is an opaque payload produced by OTP encryption on the client.

The backend must treat it as:
- untrusted input
- opaque bytes
- non-inspectable

### Burn
A burn is a signal meaning:
- “Forget this conversation state as soon as you see this.”

Burn is **best-effort**.  
If a device is offline, it receives burn when it next connects.

---

## Data handling

### What the backend may store (ephemeral)
- `conversation_id -> encrypted blobs`
- `conversation_id -> burn flag (timestamp)`
- `conversation_id -> registered device tokens (APNS)`
- operational counters (aggregate)

### TTL policy (v1 recommended defaults)
- Encrypted blobs: **30 seconds**
- Burn flag: **5 minutes**
- Device tokens: session-bound (or **24 hours max**) depending on implementation

The backend must delete expired data automatically.

### Persistence
- Allowed: in-memory or short-lived DB (e.g., SQLite/Postgres) **only if TTL enforced**
- Disallowed: backups, long retention, archives, analytics stores

---

## Transport model

### Polling-first (v1)
v1 assumes **HTTP polling** is sufficient.

- When a conversation screen is open: poll every **1–2 seconds**
- When app is backgrounded: no polling
- APNS is used only as a wake-up signal

WebSockets may be added later but are out of scope for v1.

---

## Authentication / authorization model

v1 uses **no accounts**.

Access control is minimal and based on possession of the Conversation ID.

The backend may add **opaque capability tokens** (server-issued) to reduce abuse, but must follow:

- Tokens must not encode user identity
- Tokens must not include PII
- Tokens must be revocable/expirable
- Tokens must not require escrow-like key management

---

## API surface (contract-level)

This section describes required behaviors.  
Exact paths and schemas may vary, but semantics must match.

### 1) Register device for push notifications

**Goal:** Associate a device token with a conversation (ephemerally).

- Input: `conversation_id`, `device_token`, optional `platform`
- Output: success or failure

**Invariants**
- Must not store device token longer than TTL policy
- Must not associate token with identity

---

### 2) Submit encrypted message blob

**Goal:** Accept opaque ciphertext for a conversation.

- Input: `conversation_id`, `ciphertext`, optional `client_sequence`
- Output: accepted or rejected

**Invariants**
- Store ciphertext only ephemerally
- Must enforce size limits
- Must not log ciphertext
- Should trigger silent APNS to registered devices (best-effort)

---

### 3) Poll for messages

**Goal:** Return new ciphertext blobs for a conversation.

- Input: `conversation_id`, optional `since` cursor
- Output: list of ciphertext blobs, plus next cursor

**Invariants**
- Must not reorder blobs unnecessarily
- Must allow duplicates (client must tolerate)
- Must allow empty responses
- Must not block indefinitely (short timeouts)

---

### 4) Burn conversation

**Goal:** Signal all participants to wipe state.

- Input: `conversation_id`
- Output: accepted

**Invariants**
- Must set burn flag with TTL
- Should delete queued blobs immediately for that conversation
- Should trigger silent APNS to registered devices (best-effort)

---

### 5) Poll burn status (optional)

If burn status is not piggybacked on message poll, the backend may expose burn status:

- Input: `conversation_id`, optional cursor
- Output: burn status and timestamp (if burned)

---

## Limits (must exist)

The backend must enforce defensive limits to reduce abuse and resource exhaustion.

Recommended v1 limits:
- Max ciphertext size per message: **<= 8 KB** (tunable)
- Max queued blobs per conversation: **<= 50**
- Max active conversations per IP per minute: rate limit
- Max register calls per conversation per TTL: rate limit

The backend must respond with clear errors on limit violations.

---

## Failure modes (must be acceptable)

Clients must assume the backend may:
- drop messages
- delay messages
- duplicate messages
- return out-of-date burn info briefly
- temporarily reject requests

The backend must:
- fail fast
- avoid hanging requests
- prefer correctness and simplicity over throughput

---

## Observability (privacy-preserving)

Allowed metrics (aggregate only):
- request counts per endpoint
- response status counts
- latency histograms
- queue lengths (aggregate)
- TTL cleanup counts

Disallowed:
- per-conversation analytics
- per-device analytics
- payload logging
- “user journey” tracking

---

## Security requirements

### TLS
- HTTPS only
- Modern TLS configuration
- HSTS enabled

### Input validation
- Validate sizes and formats
- Treat all input as untrusted
- Reject malformed payloads early

### Logging
- No ciphertext logging
- No device token logging
- Avoid logging conversation IDs
- Use short request IDs for correlation if needed

---

## Compatibility and versioning

The backend must support API versioning (e.g., `/v1/...`).

Breaking changes require:
- new version endpoints
- backwards-compatible rollout strategy

---

## Contract tests (recommended)

Backend implementations should include contract-level tests verifying:
- TTL deletion
- burn deletes queued blobs
- polling returns expected cursors
- size limits enforced
- no payloads written to logs in tests

---

## Final note

The backend is deliberately minimal.

If a new backend feature:
- adds identity
- adds persistent state
- interprets payloads
- or increases trust in infrastructure

it violates ASH’s architecture and must not be implemented in v1.