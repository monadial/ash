# ASH â€” Glossary

This glossary defines terms as they are used **within the ASH project**.

Words in this document may have different meanings elsewhere.  
When reading ASH documentation or code, **these definitions apply**.

---

## A

### ACK (Acknowledge)
A signal sent by the recipient to confirm a message has been displayed.

When the recipient's app displays a decrypted message, it sends an ACK to the server:
- Server immediately deletes the message from RAM
- Server broadcasts a **Delivery Report** to the sender via SSE
- ACK is idempotent (safe to retry if network fails)

ACK is sent on **display**, not just receipt. This ensures the message was actually seen.

---

### ASH
The project name.
A secure, ephemeral messaging system designed for high-security, low-frequency communication using One-Time Pad encryption and explicit human verification.

---

### Auth Token
A 256-bit token derived deterministically from pad bytes during ceremony.

Used to authenticate API requests to the relay server. Both parties compute the same token from the shared pad, enabling authorization without accounts or identity.

Derived from bytes 32-95 of the pad with domain separation.

---

## B

### Backend
The untrusted server component that relays encrypted blobs and burn signals between devices.

The backend:
- never sees plaintext
- never holds keys
- never identifies users

---

### Blob (Encrypted Blob)
An opaque sequence of bytes produced by OTP encryption on the client.

Blobs:
- are not interpreted by the backend
- may represent messages or control signals
- are ephemeral and TTL-limited

---

### Burn
An explicit action that irreversibly destroys a conversation's state.

A burn:
- wipes remaining pad material
- deletes stored encrypted blobs
- propagates best-effort to the other participant

Burn is final and non-recoverable.

---

### Burn Token
A 256-bit token derived deterministically from pad bytes during ceremony.

Used specifically for burn operations on the relay server. Separate from the auth token to provide defense-in-depth: knowing the auth token is not enough to burn a conversation.

Derived from bytes 96-159 of the pad with domain separation.

---

## C

### Ceremony
The offline, explicit process by which two devices establish a shared One-Time Pad.

The ceremony involves:
- entropy generation
- QR code transfer
- frame validation
- mnemonic verification

A ceremony must be restarted entirely on failure.

---

### Ceremony Metadata
Settings transferred alongside the pad during ceremony, encoded in frame 0.

Contains:
- Message TTL (how long messages wait on server)
- Disappearing messages timeout (how long messages show on screen)
- Relay server URL

Metadata is encoded in extended frame format with the METADATA flag.

---

### Checksum (Mnemonic)
A short, human-readable sequence of words derived deterministically from pad material.

Used by participants to visually verify that both devices share the same pad.

ASH uses a **custom wordlist** (not BIP-39) optimized for:
- Verbal clarity (distinct pronunciation)
- Cross-language usability
- Minimal confusion between similar words

---

### Conversation
A one-to-one communication context between two participants that shares a single One-Time Pad.

Conversations:
- are created via a ceremony
- have no accounts or identities
- can be burned irreversibly

---

### Conversation ID
An opaque identifier for a conversation, generated by the clients.

Used only for routing by the backend.  
Does not encode identity.

---

## D

### Delivery Report
A notification sent to the message sender when the recipient has displayed (ACKed) their message.

Delivered via SSE as:
```json
{"type": "delivered", "blob_id": "uuid", "delivered_at": "..."}
```

Properties:
- Best-effort delivery (sender may be offline)
- Confirms message was **displayed**, not just received
- Triggered immediately when server receives ACK
- Enables sender's UI to show read/delivered status

---

### Deterministic
A property meaning the same input always produces the same output.

ASH requires deterministic behavior in cryptographic and framing logic to enable testing and verification.

---

### Disappearing Messages
A client-side display timer that automatically removes messages from the screen after viewing.

Configured during ceremony as part of ceremony metadata:
- 0 = off (messages persist on screen until app closes)
- Non-zero = seconds until message disappears from UI after viewing

This is separate from server TTL and provides additional ephemerality.

---

## E

### Entropy
Unpredictable input used to generate the One-Time Pad.

In ASH, entropy may include:
- OS-provided randomness
- user-generated input (e.g., touch gestures)

Entropy quality directly affects security.

---

### Ephemeral
Data that exists only briefly and is intentionally destroyed.

In ASH:
- plaintext messages are ephemeral
- encrypted blobs are TTL-limited
- pads are consumed and wiped

---

## F

### Frame
A chunk of pad data encoded for transfer during the ceremony.

Frames:
- have fixed maximum size
- include integrity checks (CRC-32)
- are transferred via QR codes

---

### Extended Frame
An enhanced frame format used for ceremony transfers with additional features.

Extended frames include:
- Magic byte (`0xA5`) for format identification
- Flags byte for encryption and metadata indicators
- Larger maximum payload (1500 bytes vs 1000 for basic frames)
- Support for optional passphrase encryption
- Ceremony metadata in frame 0

Backwards compatible with basic frame format.

---

## I

### Initiator
The person who creates and initiates a ceremony.

The initiator:
- Generates the One-Time Pad
- Displays QR codes for transfer
- Consumes pad bytes from the **start** when sending messages

See also: **Responder**, **Role**

---

### FFI (Foreign Function Interface)
The boundary between Rust (`core`) and platform code (Swift, Kotlin).

ASH uses **UniFFI** to generate bindings from a single interface definition.

FFI exposes safe, minimal APIs and prevents reimplementation of security logic.

---

### FCM (Firebase Cloud Messaging)
Google's push notification service for Android devices.

Will be used by ASH for Android push notifications when Android support is added.

---

## G

### Gesture Entropy
Unpredictable input collected from user touch gestures during the ceremony.

In ASH, gesture entropy:
- Is mixed with OS-provided randomness
- Captures touch coordinates, timing, and pressure
- Requires minimum gesture duration
- Provides visual feedback during collection

Gesture entropy collection is **required** before pad generation.

---

## H

### Human-verifiable
A property meaning users can independently confirm correctness without trusting hidden systems.

In ASH, this includes:
- visual checksum verification
- explicit ceremony steps
- visible failure states

---

## I

### Integrity Check
A mechanism to detect accidental corruption of data (e.g., CRC).

Integrity checks detect errors but do not provide secrecy.

---

## L

### Location Message
A one-shot message containing geographic coordinates.

Format:
- Latitude: 6 decimal places (~10cm precision)
- Longitude: 6 decimal places (~10cm precision)
- No altitude, speed, or heading data

Location messages are ephemeral like text messages and consume pad bytes.

---

## M

### Mnemonic
See **Checksum (Mnemonic)**.

---

## O

### One-Time Pad (OTP)
A cryptographic system where:
- a random key is as long as the message
- the key is used exactly once
- encryption is information-theoretically secure

ASH uses OTP exclusively.

---

### Opaque
Data whose internal structure is unknown and irrelevant to a component.

The backend treats all encrypted blobs as opaque.

---

## P

### Pad
The shared random byte sequence used for OTP encryption.

Pads:
- are generated during the ceremony
- are consumed sequentially (bidirectionally)
- must never be reused

---

### Pad Size
The size of the One-Time Pad, selected during ceremony creation.

Available sizes:
- Tiny: 32 KB (~25 messages, ~37 frames)
- Small: 64 KB (~50 messages, ~74 frames)
- Medium: 256 KB (~200 messages, ~295 frames)
- Large: 512 KB (~400 messages, ~590 frames)
- Huge: 1 MB (~800 messages, ~1179 frames)

Larger pads allow more messages but require longer ceremony transfer times.

---

### Passphrase (Ceremony)
An optional verbally-shared secret used to encrypt QR frame payloads during ceremony.

Properties:
- 4-64 printable ASCII characters
- XOR'd with derived key stream
- Different key per frame index
- Protects against casual visual observation

**NOT** a replacement for performing the ceremony privately.

---

### Polling
A client-initiated request pattern where the client periodically asks the backend for new data.

Used in ASH v1 instead of persistent connections.

---

## R

### Relay
Another term for the backend's role.

A relay forwards data without understanding it.

---

### Responder
The person who receives and scans a ceremony.

The responder:
- Scans QR codes from the initiator
- Reconstructs the One-Time Pad
- Consumes pad bytes from the **end** when sending messages

See also: **Initiator**, **Role**

---

### Role
The designation of a participant in a conversation as either **Initiator** or **Responder**.

Roles determine:
- Which direction pad bytes are consumed (start vs end)
- Which party created the ceremony

Roles are:
- Assigned during the ceremony
- Fixed for the lifetime of the conversation
- Used for bidirectional pad consumption

---

## S

### Shared Rust Core (`ash-core`)
The authoritative library containing all cryptographic and procedural logic.

It is:
- deterministic
- auditable
- platform-agnostic

---

### Silent Push Notification
A push notification used only to wake the app, not to display content.

Used by ASH to prompt SSE connection or polling.

---

### SSE (Server-Sent Events)
A web technology enabling real-time, unidirectional data streaming from server to client.

In ASH, SSE is used for:
- Real-time message delivery without polling
- Burn event propagation
- Keep-alive pings (every 15 seconds)

Endpoint: `GET /v1/messages/stream?conversation_id=...`

SSE is the primary delivery mechanism. Polling is the fallback when SSE is unavailable.

---

### Server TTL
The duration messages are stored on the relay server before automatic deletion.

In ASH v1:
- **Configurable** during ceremony (5 minutes to 7 days)
- Default: 5 minutes (maximum ephemerality)
- Maximum: 7 days (604,800 seconds)
- Messages deleted on ACK or TTL expiry, whichever comes first
- Stored in ceremony metadata (frame 0)

See also: **Disappearing Messages** (client-side display timer)

---

## T

### Token Re-registration
The process of re-registering a conversation's tokens after server restart.

Since all server data is stored in RAM only:
- Server restart = all auth data lost
- Clients receive 404 "conversation not found" errors

**Re-registration steps:**

1. **Conversation tokens** - `POST /v1/conversations`
   ```json
   {
     "conversation_id": "...",
     "auth_token_hash": "sha256(auth_token)",
     "burn_token_hash": "sha256(burn_token)"
   }
   ```

2. **Device token** - `POST /v1/register`
   ```json
   {
     "conversation_id": "...",
     "device_token": "<apns_token>",
     "platform": "ios"
   }
   ```

Both endpoints are idempotent. Clients can re-register proactively on app launch.

This is intentional: no persistent server state for maximum security.

---

### TTL (Time To Live)
A duration after which data is automatically deleted.

Used by the backend to enforce ephemerality.

---

### Trust Boundary
A boundary where assumptions about behavior or security change.

ASH explicitly defines trust boundaries between:
- core
- app
- backend
- network
- users

---

## U

### UniFFI
Mozilla's Uniform Foreign Function Interface tool for Rust.

UniFFI generates language bindings from a single Rust interface definition, ensuring consistent behavior across platforms.

ASH uses UniFFI to generate Swift bindings. Kotlin bindings will be added when Android support is implemented.

---

### Untrusted
A component assumed to be potentially malicious or compromised.

In ASH:
- the backend is untrusted
- the network is untrusted
- infrastructure is untrusted

---

## W

### Wipe
Best-effort destruction of sensitive data from memory and storage.

Wiping reduces risk but does not guarantee forensic irrecoverability.

---

## Final note

This glossary exists to prevent ambiguity.

If a term is unclear or overloaded:
- clarify it here
- update documentation before updating code

In ASH, **shared language is part of security**.