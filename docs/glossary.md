# ASH — Glossary

This glossary defines terms as they are used **within the ASH project**.

Words in this document may have different meanings elsewhere.  
When reading ASH documentation or code, **these definitions apply**.

---

## A

### ASH
The project name.  
A secure, ephemeral messaging system designed for high-security, low-frequency communication using One-Time Pad encryption and explicit human verification.

---

## B

### Backend
The untrusted server component that relays encrypted blobs and burn signals between devices.

The backend:
- never sees plaintext
- never holds keys
- never identifies users

---

### Blob (Encrypted Blob)
An opaque sequence of bytes produced by OTP encryption on the client.

Blobs:
- are not interpreted by the backend
- may represent messages or control signals
- are ephemeral and TTL-limited

---

### Burn
An explicit action that irreversibly destroys a conversation’s state.

A burn:
- wipes remaining pad material
- deletes stored encrypted blobs
- propagates best-effort to the other participant

Burn is final and non-recoverable.

---

## C

### Ceremony
The offline, explicit process by which two devices establish a shared One-Time Pad.

The ceremony involves:
- entropy generation
- QR code transfer
- frame validation
- mnemonic verification

A ceremony must be restarted entirely on failure.

---

### Checksum (Mnemonic)
A short, human-readable sequence of words derived deterministically from pad material.

Used by participants to visually verify that both devices share the same pad.

ASH uses a **custom wordlist** (not BIP-39) optimized for:
- Verbal clarity (distinct pronunciation)
- Cross-language usability
- Minimal confusion between similar words

---

### Conversation
A one-to-one communication context between two participants that shares a single One-Time Pad.

Conversations:
- are created via a ceremony
- have no accounts or identities
- can be burned irreversibly

---

### Conversation ID
An opaque identifier for a conversation, generated by the clients.

Used only for routing by the backend.  
Does not encode identity.

---

## D

### Deterministic
A property meaning the same input always produces the same output.

ASH requires deterministic behavior in cryptographic and framing logic to enable testing and verification.

---

## E

### Entropy
Unpredictable input used to generate the One-Time Pad.

In ASH, entropy may include:
- OS-provided randomness
- user-generated input (e.g., touch gestures)

Entropy quality directly affects security.

---

### Ephemeral
Data that exists only briefly and is intentionally destroyed.

In ASH:
- plaintext messages are ephemeral
- encrypted blobs are TTL-limited
- pads are consumed and wiped

---

## F

### Frame
A chunk of pad data encoded for transfer during the ceremony.

Frames:
- have fixed maximum size
- include integrity checks
- are transferred via QR codes

---

### FFI (Foreign Function Interface)
The boundary between Rust (`core`) and platform code (Swift, Kotlin).

ASH uses **UniFFI** to generate bindings from a single interface definition.

FFI exposes safe, minimal APIs and prevents reimplementation of security logic.

---

### FCM (Firebase Cloud Messaging)
Google's push notification service for Android devices.

Will be used by ASH for Android push notifications when Android support is added.

---

## G

### Gesture Entropy
Unpredictable input collected from user touch gestures during the ceremony.

In ASH, gesture entropy:
- Is mixed with OS-provided randomness
- Captures touch coordinates, timing, and pressure
- Requires minimum gesture duration
- Provides visual feedback during collection

Gesture entropy collection is **required** before pad generation.

---

## H

### Human-verifiable
A property meaning users can independently confirm correctness without trusting hidden systems.

In ASH, this includes:
- visual checksum verification
- explicit ceremony steps
- visible failure states

---

## I

### Integrity Check
A mechanism to detect accidental corruption of data (e.g., CRC).

Integrity checks detect errors but do not provide secrecy.

---

## L

### Location Message
A one-shot message containing geographic coordinates.

Format:
- Latitude: 6 decimal places (~10cm precision)
- Longitude: 6 decimal places (~10cm precision)
- No altitude, speed, or heading data

Location messages are ephemeral like text messages and consume pad bytes.

---

## M

### Mnemonic
See **Checksum (Mnemonic)**.

---

## O

### One-Time Pad (OTP)
A cryptographic system where:
- a random key is as long as the message
- the key is used exactly once
- encryption is information-theoretically secure

ASH uses OTP exclusively.

---

### Opaque
Data whose internal structure is unknown and irrelevant to a component.

The backend treats all encrypted blobs as opaque.

---

## P

### Pad
The shared random byte sequence used for OTP encryption.

Pads:
- are generated during the ceremony
- are consumed sequentially
- must never be reused

---

### Polling
A client-initiated request pattern where the client periodically asks the backend for new data.

Used in ASH v1 instead of persistent connections.

---

## R

### Relay
Another term for the backend’s role.

A relay forwards data without understanding it.

---

## S

### Shared Rust Core (`ash-core`)
The authoritative library containing all cryptographic and procedural logic.

It is:
- deterministic
- auditable
- platform-agnostic

---

### Silent Push Notification
A push notification used only to wake the app, not to display content.

Used by ASH to prompt polling.

---

## T

### TTL (Time To Live)
A duration after which data is automatically deleted.

Used by the backend to enforce ephemerality.

---

### Trust Boundary
A boundary where assumptions about behavior or security change.

ASH explicitly defines trust boundaries between:
- core
- app
- backend
- network
- users

---

## U

### UniFFI
Mozilla's Uniform Foreign Function Interface tool for Rust.

UniFFI generates language bindings from a single Rust interface definition, ensuring consistent behavior across platforms.

ASH uses UniFFI to generate Swift bindings. Kotlin bindings will be added when Android support is implemented.

---

### Untrusted
A component assumed to be potentially malicious or compromised.

In ASH:
- the backend is untrusted
- the network is untrusted
- infrastructure is untrusted

---

## W

### Wipe
Best-effort destruction of sensitive data from memory and storage.

Wiping reduces risk but does not guarantee forensic irrecoverability.

---

## Final note

This glossary exists to prevent ambiguity.

If a term is unclear or overloaded:
- clarify it here
- update documentation before updating code

In ASH, **shared language is part of security**.