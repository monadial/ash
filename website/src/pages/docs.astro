---
import Layout from '../layouts/Layout.astro'
---

<Layout title="A One-Time Pad Messaging Protocol">
  <!-- Title Block -->
  <header class="mb-8">
    <h1 class="paper-title">
      ASH: A One-Time Pad Messaging Protocol for Information-Theoretic Security
    </h1>
    <p class="paper-subtitle">
      Secure ephemeral messaging with zero infrastructure trust
    </p>
    <p class="paper-date">
      Draft v0.1 &middot; January 2025
    </p>
  </header>

  <!-- Abstract -->
  <div class="abstract">
    <div class="abstract-title">Abstract</div>
    <p class="mb-0">
      We present ASH, a messaging protocol that provides information-theoretic security
      through One-Time Pad (OTP) encryption. Unlike computational security approaches,
      OTP guarantees that encrypted messages remain secure regardless of advances in
      computing power or cryptanalytic techniques. ASH addresses the traditional
      limitations of OTP systems through a novel ceremony protocol for secure key
      exchange, bidirectional pad consumption for independent messaging, and a
      zero-trust relay architecture. The protocol is designed for high-security,
      low-frequency communication scenarios where the cost of in-person key exchange
      is justified by the security requirements.
    </p>
  </div>

  <!-- Table of Contents -->
  <nav class="toc">
    <div class="toc-title">Contents</div>
    <ol>
      <li><a href="#introduction">1. Introduction</a></li>
      <li><a href="#background">2. Background</a></li>
      <li><a href="#architecture">3. System Architecture</a></li>
      <li><a href="#ceremony">4. Ceremony Protocol</a></li>
      <li><a href="#messaging">5. Messaging Protocol</a></li>
      <li><a href="#relay">6. Relay Server</a></li>
      <li><a href="#security">7. Security Properties</a></li>
      <li><a href="#data-lifecycle">8. Data Lifecycle</a></li>
      <li><a href="#limitations">9. Limitations</a></li>
      <li><a href="#applications">10. Applications</a></li>
    </ol>
  </nav>

  <!-- 1. Introduction -->
  <section>
    <h2 id="introduction" class="section-heading">1. Introduction</h2>

    <p>
      Modern secure messaging systems rely on computational security assumptions.
      Protocols such as Signal, based on the Double Ratchet algorithm, derive their
      security from the presumed difficulty of certain mathematical problems. While
      these systems provide excellent practical security, they cannot offer absolute
      guarantees against future cryptanalytic advances or the development of quantum
      computers capable of breaking current public-key cryptography.
    </p>

    <p>
      The One-Time Pad (OTP) remains the only encryption system with a mathematical
      proof of perfect secrecy. First described by Vernam in 1917 and proven secure
      by Shannon in 1949, OTP encrypts each bit of plaintext with a corresponding
      bit of truly random key material, used exactly once. The ciphertext provides
      no information about the plaintext without the key.
    </p>

    <p>
      ASH implements OTP encryption for mobile messaging, addressing three
      fundamental challenges:
    </p>

    <ol>
      <li><strong>Key distribution</strong> &mdash; How do parties securely share the pad?</li>
      <li><strong>Bidirectional communication</strong> &mdash; How do both parties send messages independently?</li>
      <li><strong>Infrastructure trust</strong> &mdash; How do we minimize trust in servers and networks?</li>
    </ol>

    <p>
      This document describes the ASH protocol design, including the ceremony
      for key exchange, the message encryption format, the relay server architecture,
      and the security properties that result from these design choices.
    </p>
  </section>

  <!-- 2. Background -->
  <section>
    <h2 id="background" class="section-heading">2. Background</h2>

    <h3 class="subsection-heading">2.1 One-Time Pad Properties</h3>

    <p>
      A One-Time Pad provides perfect secrecy when three conditions are met:
    </p>

    <ol>
      <li>The key is at least as long as the message</li>
      <li>The key is truly random</li>
      <li>The key is never reused</li>
    </ol>

    <p>
      When these conditions hold, the ciphertext is statistically independent of the
      plaintext. An adversary with infinite computational resources cannot distinguish
      between possible plaintexts&mdash;each is equally likely given the ciphertext.
    </p>

    <figure>
      <div class="diagram">Encryption:   C = P ⊕ K
Decryption:   P = C ⊕ K

Where:
  P = Plaintext bytes
  K = Key bytes (pad)
  C = Ciphertext bytes
  ⊕ = XOR operation (bitwise exclusive or)</div>
      <figcaption>Figure 1: One-Time Pad encryption and decryption</figcaption>
    </figure>

    <h3 class="subsection-heading">2.2 Limitations of Traditional OTP Systems</h3>

    <p>
      Historical OTP systems, such as those used for diplomatic communications during
      the Cold War, required physical courier delivery of key material. This approach
      does not scale to modern mobile communication. ASH addresses this through:
    </p>

    <ul>
      <li>QR code-based key transfer during in-person meetings</li>
      <li>Fountain codes for reliable transfer over lossy visual channels</li>
      <li>Mnemonic checksums for human-verifiable integrity</li>
    </ul>

    <h3 class="subsection-heading">2.3 Comparison with Signal Protocol</h3>

    <table>
      <thead>
        <tr>
          <th>Property</th>
          <th>Signal</th>
          <th>ASH</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Security basis</td>
          <td>Computational (ECDH)</td>
          <td>Information-theoretic (OTP)</td>
        </tr>
        <tr>
          <td>Key exchange</td>
          <td>Remote (network)</td>
          <td>In-person (QR codes)</td>
        </tr>
        <tr>
          <td>Message capacity</td>
          <td>Unlimited</td>
          <td>Fixed (pad size)</td>
        </tr>
        <tr>
          <td>Quantum resistance</td>
          <td>Vulnerable</td>
          <td>Immune</td>
        </tr>
        <tr>
          <td>Group messaging</td>
          <td>Yes</td>
          <td>No</td>
        </tr>
        <tr>
          <td>Media sharing</td>
          <td>Yes</td>
          <td>No</td>
        </tr>
      </tbody>
    </table>
  </section>

  <!-- 3. System Architecture -->
  <section>
    <h2 id="architecture" class="section-heading">3. System Architecture</h2>

    <h3 class="subsection-heading">3.1 Component Overview</h3>

    <p>
      ASH consists of three components with distinct trust levels:
    </p>

    <figure>
      <div class="diagram">
┌─────────────────────────────────────────────────────────────────┐
│                        ASH SYSTEM                               │
├─────────────────────────────────────────────────────────────────┤
│                                                                 │
│  ┌─────────────┐                           ┌─────────────┐      │
│  │   Device A  │                           │   Device B  │      │
│  │  ┌───────┐  │                           │  ┌───────┐  │      │
│  │  │  App  │  │                           │  │  App  │  │      │
│  │  └───┬───┘  │                           │  └───┬───┘  │      │
│  │      │      │                           │      │      │      │
│  │  ┌───┴───┐  │     ┌───────────────┐     │  ┌───┴───┐  │      │
│  │  │ Core  │  │     │  Relay Server │     │  │ Core  │  │      │
│  │  │(Rust) │  │◄───►│    (Rust)     │◄───►│  │(Rust) │  │      │
│  │  └───────┘  │     │   [Untrusted] │     │  └───────┘  │      │
│  │  [Trusted]  │     └───────────────┘     │  [Trusted]  │      │
│  └─────────────┘                           └─────────────┘      │
│                                                                 │
│  Trust Levels:                                                  │
│    Core Library  = Trusted (cryptographic authority)            │
│    Mobile App    = Partial (orchestration only)                 │
│    Relay Server  = Untrusted (assumed compromised)              │
│    Network       = Untrusted (assumed hostile)                  │
│                                                                 │
└─────────────────────────────────────────────────────────────────┘
</div>
      <figcaption>Figure 2: ASH system architecture and trust boundaries</figcaption>
    </figure>

    <h3 class="subsection-heading">3.2 Core Library</h3>

    <p>
      The core library is the cryptographic authority. It is implemented in Rust
      with zero external dependencies to minimize supply chain attack surface.
      The core handles:
    </p>

    <ul>
      <li>Pad generation from entropy sources</li>
      <li>OTP encryption and decryption</li>
      <li>Pad consumption tracking and enforcement</li>
      <li>Frame encoding for QR transfer</li>
      <li>Mnemonic checksum generation</li>
      <li>Secure memory wiping</li>
    </ul>

    <h3 class="subsection-heading">3.3 Bidirectional Pad Consumption</h3>

    <p>
      Traditional OTP systems require coordination to avoid key reuse. ASH solves
      this through bidirectional consumption: the initiator consumes pad bytes from
      the beginning, the responder from the end.
    </p>

    <figure>
      <div class="diagram">
Initial State (256KB pad):
┌────────────────────────────────────────────────────────────────┐
│░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░│
└────────────────────────────────────────────────────────────────┘
 ↑                                                              ↑
 Initiator cursor (offset 0)              Responder cursor (offset 262144)


After some messages:
┌────────────────────────────────────────────────────────────────┐
│████████████░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░░████████░░│
└────────────────────────────────────────────────────────────────┘
 └──────────┘                                         └────────┘
  Initiator                                            Responder
  consumed                                             consumed
  (12KB)                                               (8KB)

Legend:
  ░ = Unused pad bytes (available)
  █ = Consumed pad bytes (zeroed after use)
</div>
      <figcaption>Figure 3: Bidirectional pad consumption model</figcaption>
    </figure>

    <p>
      Each message includes metadata specifying the byte range consumed. Clients
      track both their own and peer's consumption to calculate remaining capacity.
      When consumption fronts meet, the pad is exhausted and no further messages
      can be sent.
    </p>

    <h3 class="subsection-heading">3.4 Pad Sizes</h3>

    <table>
      <thead>
        <tr>
          <th>Size</th>
          <th>Bytes</th>
          <th>Approx. Messages</th>
          <th>QR Frames</th>
          <th>Transfer Time</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Small</td>
          <td>64 KB</td>
          <td>~500</td>
          <td>~44</td>
          <td>~10 seconds</td>
        </tr>
        <tr>
          <td>Medium</td>
          <td>256 KB</td>
          <td>~2,000</td>
          <td>~175</td>
          <td>~30 seconds</td>
        </tr>
        <tr>
          <td>Large</td>
          <td>1 MB</td>
          <td>~8,000</td>
          <td>~700</td>
          <td>~2 minutes</td>
        </tr>
      </tbody>
    </table>
  </section>

  <!-- 4. Ceremony Protocol -->
  <section>
    <h2 id="ceremony" class="section-heading">4. Ceremony Protocol</h2>

    <p>
      The ceremony is a one-time key exchange performed when both parties are
      physically present. It establishes the shared pad without relying on any
      network or server infrastructure.
    </p>

    <h3 class="subsection-heading">4.1 Ceremony Flow</h3>

    <figure>
      <div class="diagram">
┌─────────────────┐                      ┌─────────────────┐
│    INITIATOR    │                      │    RESPONDER    │
└────────┬────────┘                      └────────┬────────┘
         │                                        │
         │  1. Select pad size                    │
         │  2. Collect gesture entropy            │
         │  3. Generate random pad                │
         │                                        │
         │  4. Encode pad with fountain codes     │
         │                                        │
         │         ┌──────────────┐               │
         │         │   QR Codes   │               │
         │    ────►│  (streaming) │────►          │
         │         └──────────────┘               │
         │                                        │
         │                           5. Scan QR codes
         │                           6. Decode fountain frames
         │                           7. Reconstruct pad
         │                                        │
         │  8. Generate mnemonic                  │  8. Generate mnemonic
         │     from pad hash                      │     from pad hash
         │                                        │
         │         ┌──────────────┐               │
         │         │   "alpha     │               │
         │         │    bravo     │               │
         │    ◄───►│    charlie   │◄───►          │
         │         │    delta     │               │
         │         │    echo      │               │
         │         │    foxtrot"  │               │
         │         └──────────────┘               │
         │                                        │
         │  9. Verbal verification                │  9. Verbal verification
         │     (compare mnemonics)                │     (compare mnemonics)
         │                                        │
         │  10. Store pad locally                 │  10. Store pad locally
         │      (encrypted)                       │      (encrypted)
         │                                        │
         ▼                                        ▼
    ┌─────────┐                              ┌─────────┐
    │  Ready  │                              │  Ready  │
    └─────────┘                              └─────────┘
</div>
      <figcaption>Figure 4: Ceremony protocol sequence</figcaption>
    </figure>

    <h3 class="subsection-heading">4.2 Entropy Collection</h3>

    <p>
      Pad generation combines multiple entropy sources:
    </p>

    <ul>
      <li><strong>OS entropy</strong> &mdash; Cryptographic randomness from the operating system (SecRandomCopyBytes on iOS)</li>
      <li><strong>Gesture entropy</strong> &mdash; Touch coordinates and timing from user drawing patterns</li>
      <li><strong>Sensor entropy</strong> &mdash; Device accelerometer and gyroscope readings</li>
    </ul>

    <p>
      This defense-in-depth approach ensures that compromise of any single entropy
      source does not compromise pad randomness. The gesture requirement also
      ensures active user participation in key generation.
    </p>

    <h3 class="subsection-heading">4.3 Fountain Codes</h3>

    <p>
      QR code scanning is inherently lossy&mdash;frames may be missed due to motion,
      focus issues, or partial occlusion. ASH uses fountain codes (rateless erasure
      codes) to ensure reliable transfer.
    </p>

    <figure>
      <div class="diagram">Fountain Code Structure:

Source blocks (K blocks):
┌─────┬─────┬─────┬─────┬─────┬─────┬─────┬─────┐
│  0  │  1  │  2  │  3  │  4  │  5  │  6  │  7  │  ... K-1
└─────┴─────┴─────┴─────┴─────┴─────┴─────┴─────┘
   │     │     │     │     │     │     │     │
   └─────┴─────┴─────┴─────┴─────┴─────┴─────┴──── Direct transmission

XOR blocks (redundancy):
┌─────────────┬─────────────┬─────────────┬─────────────┐
│  0 ⊕ 3     │  1 ⊕ 5     │  2 ⊕ 7     │  4 ⊕ 6     │  ...
└─────────────┴─────────────┴─────────────┴─────────────┘
       │             │             │             │
       └─────────────┴─────────────┴─────────────┴──── Recovery blocks

Properties:
  • First K frames = source data (no overhead if received)
  • Additional frames = XOR combinations for recovery
  • Any ~K frames sufficient to reconstruct original
  • No specific ordering required
  • Deterministic: same index always produces same block</div>
      <figcaption>Figure 5: Fountain code block structure</figcaption>
    </figure>

    <h3 class="subsection-heading">4.4 QR Frame Format</h3>

    <p>
      Each QR code contains a single fountain-encoded frame:
    </p>

    <figure>
      <div class="diagram">Frame Layout (1516 bytes total):
┌──────────────────────────────────────────────────────────────┐
│ Offset │ Size │ Field                                        │
├────────┼──────┼──────────────────────────────────────────────┤
│   0    │  4   │ Block index (big-endian u32)                 │
│   4    │  2   │ Source block count (big-endian u16)          │
│   6    │  2   │ Block size (big-endian u16)                  │
│   8    │  4   │ Original data length (big-endian u32)        │
│  12    │  N   │ Block data (1500 bytes)                      │
│ 12+N   │  4   │ CRC-32 checksum (big-endian u32)             │
└──────────────────────────────────────────────────────────────┘

The frame is base64-encoded for QR compatibility.
Total encoded size: ~2021 characters (fits QR Version 23-24 with L correction)</div>
      <figcaption>Figure 6: QR frame binary format</figcaption>
    </figure>

    <h3 class="subsection-heading">4.5 Mnemonic Verification</h3>

    <p>
      After transfer, both devices compute a checksum of the pad and encode it as
      six words from a 512-word vocabulary. This provides 54 bits of verification
      entropy (9 bits per word × 6 words).
    </p>

    <figure>
      <div class="diagram">Mnemonic Generation:

┌───────────┐    ┌─────────────┐    ┌────────────────┐    ┌─────────────────┐
│    Pad    │───►│  SHA-256    │───►│ Extract 54     │───►│  Split into 6   │
│  (bytes)  │    │   (hash)    │    │ bits of hash   │    │  9-bit indices  │
└───────────┘    └─────────────┘    └────────────────┘    └────────┬────────┘
                                                                   │
                      ┌────────────────────────────────────────────┘
                      │
                      ▼
            ┌──────────────────┐    ┌─────────────────────────────────────┐
            │  512-word        │───►│  "alpha bravo charlie               │
            │  vocabulary      │    │   delta echo foxtrot"               │
            │  (9 bits = 512)  │    │                                     │
            └──────────────────┘    └─────────────────────────────────────┘

Example:
  Hash:     0x7A3F... → extract bits → [127, 284, 51, 439, 102, 371]
  Mnemonic: "alpha bravo charlie delta echo foxtrot"

Security: Collision probability = 1 in 2^54 ≈ 1 in 18 quadrillion</div>
      <figcaption>Figure 7: Mnemonic checksum generation</figcaption>
    </figure>

    <p>
      Users compare these words verbally&mdash;a process resistant to man-in-the-middle
      attacks that cannot be performed without physical presence. If the words do
      not match, the ceremony has failed and must be restarted.
    </p>

    <h3 class="subsection-heading">4.6 Optional Passphrase Protection</h3>

    <p>
      The ceremony optionally supports passphrase encryption of QR frames. When enabled,
      frames are encrypted with a key derived from a shared passphrase before display.
      This provides defense against visual observation attacks if the passphrase is
      communicated through a separate secure channel.
    </p>
  </section>

  <!-- 5. Messaging Protocol -->
  <section>
    <h2 id="messaging" class="section-heading">5. Messaging Protocol</h2>

    <h3 class="subsection-heading">5.1 Message Encryption</h3>

    <p>
      Each message is encrypted by XORing plaintext bytes with the next unused
      pad bytes from the sender's side.
    </p>

    <figure>
      <div class="diagram">Message Encryption Flow:

    Plaintext               Pad (unused)            Ciphertext
        │                       │                       │
        ▼                       ▼                       ▼
┌───────────────┐       ┌───────────────┐       ┌───────────────┐
│   "Hello"     │       │ Bytes at      │       │   Encrypted   │
│               │  XOR  │ offset N      │   =   │   Output      │
│ 48 65 6C 6C   │ ───── │ A3 F1 2B 7E   │ ───── │ EB 94 47 12   │
│ 6F            │       │ 90            │       │ FF            │
└───────────────┘       └───────┬───────┘       └───────────────┘
                                │
                                ▼
                    ┌───────────────────────┐
                    │   Consumed pad bytes  │
                    │   zeroed immediately  │
                    │   (volatile writes)   │
                    └───────────────────────┘</div>
      <figcaption>Figure 8: OTP encryption operation</figcaption>
    </figure>

    <h3 class="subsection-heading">5.2 Message Frame Format</h3>

    <figure>
      <div class="diagram">Encrypted Message Frame:
┌──────────────────────────────────────────────────────────────┐
│ Offset │ Size │ Field                                        │
├────────┼──────┼──────────────────────────────────────────────┤
│   0    │  4   │ Pad offset (big-endian u32)                  │
│   4    │  2   │ Ciphertext length (big-endian u16)           │
│   6    │  N   │ Ciphertext bytes                             │
│  6+N   │  4   │ CRC-32 checksum (big-endian u32)             │
└──────────────────────────────────────────────────────────────┘

The message frame is then wrapped in the relay envelope (see Section 6).</div>
      <figcaption>Figure 9: Encrypted message frame format</figcaption>
    </figure>

    <h3 class="subsection-heading">5.3 Message Types</h3>

    <p>
      ASH supports two message types:
    </p>

    <dl class="definition-list">
      <dt>Text Messages</dt>
      <dd>UTF-8 encoded text. Maximum length determined by available pad space.</dd>

      <dt>Location Messages</dt>
      <dd>GPS coordinates encoded as two 32-bit floats (latitude, longitude) with 6 decimal places (~10cm precision). Total: 8 bytes of pad consumption.</dd>
    </dl>

    <h3 class="subsection-heading">5.4 Message Lifecycle</h3>

    <figure>
      <div class="diagram">Message State Machine:

    ┌─────────────┐
    │  Composed   │  User enters text/location
    └──────┬──────┘
           │
           ▼
    ┌─────────────┐
    │  Encrypted  │  XOR with pad bytes
    └──────┬──────┘
           │
           ▼
    ┌─────────────┐
    │   Queued    │  Waiting for network
    └──────┬──────┘
           │
           ▼
    ┌─────────────┐
    │    Sent     │  Uploaded to relay
    └──────┬──────┘
           │
           ▼
    ┌─────────────┐
    │   Stored    │  Held on relay (TTL countdown)
    └──────┬──────┘
           │
           ├──────────────────┐
           │                  │
           ▼                  ▼
    ┌─────────────┐    ┌─────────────┐
    │  Delivered  │    │   Expired   │  TTL exceeded
    └──────┬──────┘    └─────────────┘
           │
           ▼
    ┌─────────────┐
    │  Decrypted  │  XOR with matching pad bytes
    └──────┬──────┘
           │
           ▼
    ┌─────────────┐
    │  Displayed  │  Shown to recipient
    └──────┬──────┘
           │
           ▼
    ┌─────────────┐
    │  Destroyed  │  Pad bytes zeroed, message cleared
    └─────────────┘</div>
      <figcaption>Figure 10: Message lifecycle states</figcaption>
    </figure>

    <h3 class="subsection-heading">5.5 Burn Protocol</h3>

    <p>
      Either party can initiate a "burn" to destroy the conversation:
    </p>

    <figure>
      <div class="diagram">Burn Sequence:

Device A (initiator):                    Device B:
─────────────────────                    ─────────────────
       │                                        │
       │  1. User initiates burn                │
       │                                        │
       ▼                                        │
┌──────────────┐                                │
│ Wipe local   │                                │
│ pad material │                                │
│ (volatile    │                                │
│  writes)     │                                │
└──────┬───────┘                                │
       │                                        │
       │  2. Send burn signal to relay          │
       │                                        │
       │         ┌─────────┐                    │
       │────────►│  Relay  │                    │
       │         │         │                    │
       │         │ Delete  │                    │
       │         │ stored  │                    │
       │         │ messages│                    │
       │         └────┬────┘                    │
       │              │                         │
       │              │  3. Forward burn        │
       │              │     notification        │
       │              │                         │
       │              └────────────────────────►│
       │                                        │
       │                                        ▼
       │                                ┌──────────────┐
       │                                │ Wipe local   │
       │                                │ pad material │
       │                                │ (volatile    │
       │                                │  writes)     │
       │                                └──────────────┘
       │                                        │
       ▼                                        ▼
  [Destroyed]                              [Destroyed]

After burn:
  • All pad material is zeroed (multiple overwrites)
  • Conversation cannot be resumed
  • No historical messages can be decrypted
  • Burn is IRREVERSIBLE</div>
      <figcaption>Figure 11: Burn protocol sequence</figcaption>
    </figure>
  </section>

  <!-- 6. Relay Server -->
  <section>
    <h2 id="relay" class="section-heading">6. Relay Server</h2>

    <h3 class="subsection-heading">6.1 Design Philosophy</h3>

    <p>
      The relay server is designed as a minimal, untrusted component. It performs
      three functions:
    </p>

    <ol>
      <li>Temporarily store encrypted message blobs</li>
      <li>Deliver messages to recipients when they connect</li>
      <li>Propagate burn signals between devices</li>
    </ol>

    <p>
      The relay never sees plaintext, never possesses key material, and cannot
      decrypt any content. A complete compromise of the relay reveals only
      encrypted blobs and metadata.
    </p>

    <h3 class="subsection-heading">6.2 Authentication Tokens</h3>

    <p>
      Devices authenticate to the relay using conversation-specific tokens derived
      during the ceremony. Two separate tokens provide defense-in-depth:
    </p>

    <figure>
      <div class="diagram">Token Derivation:

                              ┌───────────────────────┐
                         ┌───►│ Auth Token (32 bytes) │
                         │    └───────────┬───────────┘
                         │                │
                         │                ▼
┌────────────┐      ┌────┴────┐    ┌─────────────┐    ┌────────────┐
│ Shared Pad │─────►│ Derive  │    │ SHA-256     │───►│ Server     │
│            │      │ Function│    │ (hash)      │    │ (stores    │
└────────────┘      └────┬────┘    └─────────────┘    │  hash only)│
                         │                            └────────────┘
                         │    ┌───────────────────────┐
                         └───►│ Burn Token (32 bytes) │
                              └───────────┬───────────┘
                                          │
                                          ▼
                                   ┌─────────────┐    ┌────────────┐
                                   │ SHA-256     │───►│ Server     │
                                   │ (hash)      │    │ (stores    │
                                   └─────────────┘    │  hash only)│
                                                      └────────────┘

Token Usage:
  auth_token  ─► Messages, polling, device registration
  burn_token  ─► Burn operations only (defense in depth)

Security Properties:
  • Only pad holders can derive tokens
  • Server stores hashes only, cannot reverse to get tokens
  • Separate tokens prevent privilege escalation</div>
      <figcaption>Figure 12: Authentication token derivation</figcaption>
    </figure>

    <h3 class="subsection-heading">6.3 Message Storage</h3>

    <div class="warning-box">
      <strong>Data Loss Warning:</strong> The relay server provides temporary storage
      only. Messages are stored in memory by default and may be lost due to server
      restarts, crashes, or resource constraints. ASH does not guarantee message
      delivery. Users should not rely on the relay for persistent storage.
    </div>

    <p>
      Messages are stored with a fixed 5-minute TTL. This short duration:
    </p>

    <ul>
      <li>Minimizes server-side data exposure</li>
      <li>Encourages timely message retrieval</li>
      <li>Reduces storage requirements</li>
      <li>Limits metadata accumulation</li>
    </ul>

    <p>
      Clients should poll regularly or use SSE streaming to receive messages
      before expiry. Expired messages are permanently deleted.</p>

    <h3 class="subsection-heading">6.4 Relay API</h3>

    <figure>
      <div class="diagram">Relay API Endpoints (all under /v1):

POST /v1/conversations
  Body:     conversation_id, auth_token_hash, burn_token_hash
  Response: success: true
  Purpose:  Register conversation (both parties call after ceremony)
  Auth:     None (hashes are registration credentials)

POST /v1/register
  Header:   Authorization: Bearer [auth_token]
  Body:     conversation_id, device_token, platform
  Response: success: true
  Purpose:  Register device for push notifications

POST /v1/messages
  Header:   Authorization: Bearer [auth_token]
  Body:     conversation_id, ciphertext (base64), sequence
  Response: accepted: true, blob_id
  Purpose:  Submit encrypted message (5-minute TTL)

GET /v1/messages?conversation_id=...&cursor=...
  Header:   Authorization: Bearer [auth_token]
  Response: messages: [...], next_cursor, burned
  Purpose:  Poll for pending messages

POST /v1/burn
  Header:   Authorization: Bearer [burn_token]  (NOT auth_token!)
  Body:     conversation_id
  Response: accepted: true
  Purpose:  Burn conversation, delete all messages

GET /v1/burn?conversation_id=...
  Header:   Authorization: Bearer [auth_token]
  Response: burned: true/false, burned_at
  Purpose:  Check if conversation was burned

GET /v1/messages/stream?conversation_id=...
  Header:   Authorization: Bearer [auth_token]
  Response: Server-Sent Events stream
  Events:   message (new blob), burned (conversation destroyed)
  Purpose:  Real-time updates (15s keepalive)</div>
      <figcaption>Figure 13: Relay server REST API</figcaption>
    </figure>

    <p>
      Note: The burn endpoint requires a separate <code>burn_token</code>, not
      the <code>auth_token</code>. This defense-in-depth ensures that knowing
      the auth token alone is insufficient to destroy a conversation.
    </p>

    <h3 class="subsection-heading">6.5 Push Notifications</h3>

    <p>
      The relay can send push notifications to alert users of new messages.
      Push tokens are registered separately and are not linked to conversation
      tokens to minimize metadata exposure.
    </p>

    <figure>
      <div class="diagram">Push Notification Flow:

┌──────────┐     ┌─────────┐     ┌──────────┐     ┌──────────┐
│ Sender   │────►│  Relay  │────►│   APNS   │────►│ Receiver │
│ Device   │     │ Server  │     │  Server  │     │  Device  │
└──────────┘     └─────────┘     └──────────┘     └──────────┘
                      │
                      │  Push contains:
                      │  • "New message" (no content)
                      │  • Silent push (no visible alert)
                      │
                      │  Push does NOT contain:
                      │  • Message content
                      │  • Sender identity
                      │  • Conversation identifier

Privacy note:
  APNS knows that the device received a push from ASH.
  APNS does not know message content or conversation details.</div>
      <figcaption>Figure 14: Push notification architecture</figcaption>
    </figure>

    <h3 class="subsection-heading">6.6 Rate Limiting and DoS Protection</h3>

    <p>
      The relay implements limits to prevent abuse:
    </p>

    <table>
      <thead>
        <tr>
          <th>Limit</th>
          <th>Default</th>
          <th>Purpose</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Max ciphertext size</td>
          <td>8 KB</td>
          <td>Prevent oversized message attacks</td>
        </tr>
        <tr>
          <td>Max queued messages/conversation</td>
          <td>50</td>
          <td>Prevent queue flooding</td>
        </tr>
        <tr>
          <td>Max conversations</td>
          <td>100,000</td>
          <td>Prevent memory exhaustion</td>
        </tr>
        <tr>
          <td>Inactive conversation TTL</td>
          <td>24 hours</td>
          <td>Auto-cleanup stale registrations</td>
        </tr>
        <tr>
          <td>Message TTL</td>
          <td>5 minutes</td>
          <td>Limit storage duration</td>
        </tr>
      </tbody>
    </table>

    <p>
      Additional rate limiting (requests per second, IP blocking) should be
      applied at the HTTP layer (nginx, Cloudflare, etc.).
    </p>
  </section>

  <!-- 7. Security Properties -->
  <section>
    <h2 id="security" class="section-heading">7. Security Properties</h2>

    <h3 class="subsection-heading">7.1 Guarantees</h3>

    <dl class="definition-list">
      <dt>Perfect Secrecy</dt>
      <dd>Ciphertext reveals no information about plaintext without the pad. This is proven mathematically, not assumed.</dd>

      <dt>Forward Secrecy</dt>
      <dd>Compromise of the device after a message is sent cannot reveal that message's plaintext&mdash;the pad bytes were destroyed.</dd>

      <dt>Future Secrecy</dt>
      <dd>Unlike computational systems, no future advances in computing or mathematics can break past messages.</dd>

      <dt>Relay Compromise Resistance</dt>
      <dd>Full relay server compromise reveals only encrypted blobs and timing metadata.</dd>

      <dt>No Key Escrow</dt>
      <dd>No third party possesses key material. No recovery mechanism exists.</dd>
    </dl>

    <h3 class="subsection-heading">7.2 Non-Guarantees</h3>

    <dl class="definition-list">
      <dt>Anonymity</dt>
      <dd>ASH does not hide that communication occurred. Metadata (timing, message sizes) is visible to the relay and network observers.</dd>

      <dt>Device Security</dt>
      <dd>A compromised device can read messages before encryption or after decryption.</dd>

      <dt>Coercion Resistance</dt>
      <dd>Users can be compelled to decrypt messages while the pad exists.</dd>

      <dt>Availability</dt>
      <dd>Relay downtime prevents message delivery. Messages may be lost.</dd>

      <dt>Participant Trust</dt>
      <dd>ASH cannot prevent screenshots or betrayal by conversation partners.</dd>
    </dl>

    <p>
      For a detailed threat model, see the <a href="/security">Security Model</a> document.
    </p>
  </section>

  <!-- 8. Data Lifecycle -->
  <section>
    <h2 id="data-lifecycle" class="section-heading">8. Data Lifecycle</h2>

    <h3 class="subsection-heading">8.1 Data Storage Locations</h3>

    <figure>
      <div class="diagram">Data at Rest:

┌─────────────────────────────────────────────────────────────┐
│                      CLIENT DEVICE                          │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  iOS Keychain (encrypted):                                  │
│  ├── Pad bytes (remaining unused portion)                   │
│  ├── Consumption cursors (initiator/responder offsets)      │
│  └── Conversation metadata (name, creation date)            │
│                                                             │
│  App Sandbox (encrypted):                                   │
│  └── Message history (if persistence enabled)               │
│                                                             │
│  NOT stored on device:                                      │
│  • Used pad bytes (zeroed immediately after use)            │
│  • Decrypted message content (memory only)                  │
│                                                             │
└─────────────────────────────────────────────────────────────┘

┌─────────────────────────────────────────────────────────────┐
│                      RELAY SERVER                           │
├─────────────────────────────────────────────────────────────┤
│                                                             │
│  In-memory storage (default):                               │
│  ├── Encrypted message blobs (TTL-bounded)                  │
│  ├── Token hashes (SHA-256, not raw tokens)                 │
│  └── Active SSE connections                                 │
│                                                             │
│  NOT stored on relay:                                       │
│  • Plaintext message content                                │
│  • Pad bytes or derived keys                                │
│  • Raw tokens (only hashes stored)                          │
│  • Long-term message archives                               │
│                                                             │
│  ⚠ Data may be lost on server restart                       │
│                                                             │
└─────────────────────────────────────────────────────────────┘</div>
      <figcaption>Figure 15: Data storage locations</figcaption>
    </figure>

    <h3 class="subsection-heading">8.2 Data Destruction</h3>

    <table>
      <thead>
        <tr>
          <th>Event</th>
          <th>Data Destroyed</th>
          <th>Method</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Message sent</td>
          <td>Used pad bytes</td>
          <td>Volatile zero-write</td>
        </tr>
        <tr>
          <td>Message read</td>
          <td>Plaintext (memory)</td>
          <td>Memory deallocation</td>
        </tr>
        <tr>
          <td>Burn initiated</td>
          <td>All pad material</td>
          <td>Multiple overwrites</td>
        </tr>
        <tr>
          <td>TTL expiry</td>
          <td>Relay stored blob</td>
          <td>Memory deallocation</td>
        </tr>
        <tr>
          <td>App uninstall</td>
          <td>Keychain entries</td>
          <td>OS-managed deletion</td>
        </tr>
      </tbody>
    </table>

    <h3 class="subsection-heading">8.3 iOS Backup Considerations</h3>

    <p>
      Pad material is stored in the iOS Keychain with attributes that exclude it
      from device backups. This prevents pad leakage through iCloud or iTunes
      backups. Users should be aware that:
    </p>

    <ul>
      <li>Restoring from backup will NOT restore conversations</li>
      <li>Device migration will NOT transfer conversations</li>
      <li>Each device maintains independent pad state</li>
    </ul>
  </section>

  <!-- 9. Limitations -->
  <section>
    <h2 id="limitations" class="section-heading">9. Limitations</h2>

    <p>
      ASH makes explicit trade-offs that limit its applicability:
    </p>

    <table>
      <thead>
        <tr>
          <th>Limitation</th>
          <th>Rationale</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>Physical meeting required</td>
          <td>Secure key exchange without trusting infrastructure</td>
        </tr>
        <tr>
          <td>Finite message capacity</td>
          <td>OTP requires key material equal to message length</td>
        </tr>
        <tr>
          <td>Two-party only</td>
          <td>Group OTP would require O(n²) key material</td>
        </tr>
        <tr>
          <td>Text and location only</td>
          <td>Media would exhaust pad rapidly</td>
        </tr>
        <tr>
          <td>No key recovery</td>
          <td>Recovery mechanisms create escrow risks</td>
        </tr>
        <tr>
          <td>No offline messaging</td>
          <td>Relay required for asynchronous delivery</td>
        </tr>
        <tr>
          <td>Messages may be lost</td>
          <td>Relay provides temporary storage only</td>
        </tr>
      </tbody>
    </table>

    <p>
      These limitations are intentional. ASH is not a general-purpose messenger.
      It serves specific high-security scenarios where these trade-offs are acceptable.
    </p>
  </section>

  <!-- 10. Applications -->
  <section>
    <h2 id="applications" class="section-heading">10. Applications</h2>

    <p>
      ASH is designed for scenarios where:
    </p>

    <ul>
      <li>Parties can meet in person initially</li>
      <li>Communication is infrequent but high-stakes</li>
      <li>Future cryptanalytic advances are a concern</li>
      <li>Infrastructure cannot be fully trusted</li>
      <li>Message delivery is not time-critical</li>
    </ul>

    <p>
      Example use cases include journalist-source communication, whistleblower
      coordination, human rights documentation, and personal safety scenarios.
    </p>

    <div class="warning-box">
      <strong>Ethical Notice:</strong> ASH is designed for legitimate privacy needs.
      Users are responsible for ensuring their use complies with applicable laws
      and does not facilitate harm. See the <a href="/ethics">Ethics Statement</a>
      for guidelines.
    </div>
  </section>

  <!-- References -->
  <section>
    <h2 class="section-heading">References</h2>

    <ol class="text-sm">
      <li>
        Shannon, C. E. (1949). "Communication Theory of Secrecy Systems."
        <em>Bell System Technical Journal</em>, 28(4), 656-715.
      </li>
      <li>
        Vernam, G. S. (1926). "Cipher Printing Telegraph Systems for Secret Wire
        and Radio Telegraphic Communications." <em>Journal of the AIEE</em>, 45(2), 109-115.
      </li>
      <li>
        MacKay, D. J. C. (2005). "Fountain codes." <em>IEE Proceedings-Communications</em>,
        152(6), 1062-1068.
      </li>
      <li>
        Cohn-Gordon, K., et al. (2020). "A Formal Security Analysis of the Signal
        Messaging Protocol." <em>Journal of Cryptology</em>, 33(4), 1914-1983.
      </li>
      <li>
        Luby, M. (2002). "LT Codes." <em>Proceedings of the 43rd Annual IEEE
        Symposium on Foundations of Computer Science</em>, 271-280.
      </li>
    </ol>
  </section>

  <!-- Appendix -->
  <section>
    <h2 class="section-heading">Appendix A: Cryptographic Primitives</h2>

    <p>
      ASH uses the following cryptographic primitives, all implemented without
      external dependencies:
    </p>

    <table>
      <thead>
        <tr>
          <th>Primitive</th>
          <th>Purpose</th>
          <th>Implementation</th>
        </tr>
      </thead>
      <tbody>
        <tr>
          <td>XOR</td>
          <td>OTP encryption/decryption</td>
          <td>Bitwise exclusive-or</td>
        </tr>
        <tr>
          <td>CRC-32</td>
          <td>Frame integrity checks</td>
          <td>Polynomial 0xEDB88320</td>
        </tr>
        <tr>
          <td>SHA-256</td>
          <td>Token derivation, mnemonic generation</td>
          <td>OS-provided (CommonCrypto)</td>
        </tr>
        <tr>
          <td>Volatile zero</td>
          <td>Secure memory wiping</td>
          <td>Compiler barrier + write</td>
        </tr>
      </tbody>
    </table>
  </section>

  <!-- Footnote -->
  <div class="footnote">
    <p>
      This document describes the ASH protocol design. Implementation details
      may vary. For security-critical deployments, review the source code and
      conduct independent security audits. The protocol is under active development
      and this specification may be updated.
    </p>
  </div>
</Layout>
